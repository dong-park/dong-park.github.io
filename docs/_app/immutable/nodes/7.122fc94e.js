import{S as et,i as tt,s as ft,a as Ae,c as lt,b as rt,m as st,g as at,d as Ye,t as ot,e as _t,f as ut,h as Ze,j as r,k as p,l as m,n as s,o as a,p as i,q as t,r as n,u as v,v as l,w as o,x as pt}from"../chunks/index.a6243f30.js";import{L as it}from"../chunks/LayoutDefault.47afac3f.js";function vt(R){let _,E,d,x,u,h,P,$,T,oe,V,y,_e,W,A,c,I,ue,X,b,pe,Y,H,j,J,ie,Z,q,ve,g,S,w,K,me,ee,L,ne,te,G,k,M,Ee,fe,C,he,le,N,D,Q,de,re,z,xe,se,O,B,U,Pe,ae,F,$e;return{c(){_=r("h2"),E=r("a"),d=p("소프트웨어 개발에서 명명 기술이 가지는 의미"),x=m(),u=r("p"),h=p(`코딩 영역에서 이름의 힘은 단순한 식별을 초월합니다. 변수나 메소드의 본질과 기능을 전달합니다. 따라서 소프트웨어 개발에서 명명 기술은 사소한 것이 아니라 코드 가독성과 유지 관리성을 향상시키는 중요한 기술입니다.
이 장에서는 의미 있는 이름을 만드는 원칙을 자세히 살펴보고 프로그래머가 이해와 협업을 촉진하는 모범 사례를 안내합니다.`),P=m(),$=r("h2"),T=r("a"),oe=p("의도를 분명히 밝히자"),V=m(),y=r("p"),_e=p(`의미 있는 이름 지정의 초석은 잘못된 정보를 피하는 것입니다. 오해를 불러일으키는 이름은 동료 프로그래머를 쫓기게 만들어 존재하지 않거나 예상과 다르게 작동하는 기능을 찾도록 할 수 있습니다. 이름은 변수와 함수의
목적과 사용법을 정확하게 반영하여 잘못된 가정을 방지하고 보다 직관적인 코드베이스에 기여하는 것이 중요합니다.`),W=m(),A=r("h2"),c=r("a"),I=r("strong"),ue=p("의미 있게 구별하기"),X=m(),b=r("p"),pe=p(`이름은 코드의 복잡성 속에서 목적과 정확성을 통해 명확성을 나타내는 신호 역할을 합니다. 각 식별자는 기능과 의도 모두에서 다른 식별자와 차별화되는 고유한 의미를 가져야 합니다. 이러한 명확성은 이해에 도움이 될
뿐만 아니라 기존 코드의 수정 및 확장에도 도움이 되므로 잘 정의된 개념의 견고한 기반 위에 향상된 기능이 구축되도록 보장합니다.`),Y=m(),H=r("h2"),j=r("a"),J=r("strong"),ie=p("발음 및 검색 가능성"),Z=m(),q=r("p"),ve=p(`이름을 쉽게 발음하고 검색할 수 있으므로 코드에 대한 접근성이 한 단계 더 높아집니다. 발음 가능한 이름은 개발자 간의 구두 토론을 촉진하는 반면, 검색 가능한 이름은 코드베이스 내에서 특정 함수나 변수를 빠르게
찾을 수 있도록 해줍니다. 이러한 특성은 효율적인 팀워크와 코드 유지 관리, 복잡한 시스템 탐색 및 이해 프로세스를 간소화하는 데 필수적입니다.`),g=m(),S=r("h2"),w=r("a"),K=r("strong"),me=p("인코딩 방지"),ee=m(),L=r("p"),ne=p(`인코딩, 즉 이름에 유형이나 범위 정보를 삽입하는 관행은 더 이상 최신 코더에 제공되지 않는 과거 프로그래밍 관행의 흔적입니다. 의미 있는 이름 지정은 가독성과 단순성을 위해 이러한 인코딩을 피하고 코드의 의도를
모호하게 하지 않으면서 코드의 구조와 이름 지정 규칙이 필요한 컨텍스트를 제공할 수 있도록 합니다.`),te=m(),G=r("h2"),k=r("a"),M=r("strong"),Ee=p("이름에 담긴 기억과 유머"),fe=m(),C=r("p"),he=p(`자신의 기억이나 유머 감각에 의존하여 이름을 짓는 것은 유혹적일 수 있지만 종종 혼란과 배제로 이어집니다. 너무 비밀스럽거나 내부 농담이 담긴 이름은 새로운 팀 구성원이나 향후 코드 관리자를 소외시킬 수 있습니다.
따라서 보편적으로 이해할 수 있는 이름을 선택하여 코드 자체가 표현되는 포괄적인 환경을 조성하는 것이 좋습니다.`),le=m(),N=r("h2"),D=r("a"),Q=r("strong"),de=p("방법론적 명명"),re=m(),z=r("p"),xe=p(`마지막으로, 명명에 대한 방법론적 접근 방식을 채택하는 것은 작업에 적합한 도구를 선택하는 것과 유사합니다. 여기에는 설명적이고 명확할 뿐만 아니라 프로젝트의 전반적인 명명 규칙과도 일치하는 이름을 선택하는 것이
포함됩니다. 이러한 체계적인 접근 방식을 통해 각 이름은 각 구성 요소의 목적과 기능이 즉시 드러나는 응집력 있고 탐색 가능한 코드베이스에 기여합니다.`),se=m(),O=r("h2"),B=r("a"),U=r("strong"),Pe=p("결론"),ae=m(),F=r("p"),$e=p(`광범위한 소프트웨어 개발 환경에서 의미 있는 이름은 명확성과 이해의 기둥이 됩니다. 이 장에 설명된 원칙을 준수함으로써 개발자는 기능적일 뿐만 아니라 직관적이고 유지 관리가 가능한 코드를 만들 수 있습니다.
프로그래밍의 복잡성을 탐색하면서 코드의 세계에서 이름은 레이블 그 이상이며 이해를 위한 관문이라는 점을 기억하십시오.`),this.h()},l(e){_=s(e,"H2",{id:!0});var f=a(_);E=s(f,"A",{href:!0});var He=a(E);d=i(He,"소프트웨어 개발에서 명명 기술이 가지는 의미"),He.forEach(t),f.forEach(t),x=n(e),u=s(e,"P",{});var Se=a(u);h=i(Se,`코딩 영역에서 이름의 힘은 단순한 식별을 초월합니다. 변수나 메소드의 본질과 기능을 전달합니다. 따라서 소프트웨어 개발에서 명명 기술은 사소한 것이 아니라 코드 가독성과 유지 관리성을 향상시키는 중요한 기술입니다.
이 장에서는 의미 있는 이름을 만드는 원칙을 자세히 살펴보고 프로그래머가 이해와 협업을 촉진하는 모범 사례를 안내합니다.`),Se.forEach(t),P=n(e),$=s(e,"H2",{id:!0});var Ge=a($);T=s(Ge,"A",{href:!0});var Ne=a(T);oe=i(Ne,"의도를 분명히 밝히자"),Ne.forEach(t),Ge.forEach(t),V=n(e),y=s(e,"P",{});var Oe=a(y);_e=i(Oe,`의미 있는 이름 지정의 초석은 잘못된 정보를 피하는 것입니다. 오해를 불러일으키는 이름은 동료 프로그래머를 쫓기게 만들어 존재하지 않거나 예상과 다르게 작동하는 기능을 찾도록 할 수 있습니다. 이름은 변수와 함수의
목적과 사용법을 정확하게 반영하여 잘못된 가정을 방지하고 보다 직관적인 코드베이스에 기여하는 것이 중요합니다.`),Oe.forEach(t),W=n(e),A=s(e,"H2",{id:!0});var Re=a(A);c=s(Re,"A",{href:!0});var Te=a(c);I=s(Te,"STRONG",{});var ye=a(I);ue=i(ye,"의미 있게 구별하기"),ye.forEach(t),Te.forEach(t),Re.forEach(t),X=n(e),b=s(e,"P",{});var ce=a(b);pe=i(ce,`이름은 코드의 복잡성 속에서 목적과 정확성을 통해 명확성을 나타내는 신호 역할을 합니다. 각 식별자는 기능과 의도 모두에서 다른 식별자와 차별화되는 고유한 의미를 가져야 합니다. 이러한 명확성은 이해에 도움이 될
뿐만 아니라 기존 코드의 수정 및 확장에도 도움이 되므로 잘 정의된 개념의 견고한 기반 위에 향상된 기능이 구축되도록 보장합니다.`),ce.forEach(t),Y=n(e),H=s(e,"H2",{id:!0});var be=a(H);j=s(be,"A",{href:!0});var je=a(j);J=s(je,"STRONG",{});var qe=a(J);ie=i(qe,"발음 및 검색 가능성"),qe.forEach(t),je.forEach(t),be.forEach(t),Z=n(e),q=s(e,"P",{});var we=a(q);ve=i(we,`이름을 쉽게 발음하고 검색할 수 있으므로 코드에 대한 접근성이 한 단계 더 높아집니다. 발음 가능한 이름은 개발자 간의 구두 토론을 촉진하는 반면, 검색 가능한 이름은 코드베이스 내에서 특정 함수나 변수를 빠르게
찾을 수 있도록 해줍니다. 이러한 특성은 효율적인 팀워크와 코드 유지 관리, 복잡한 시스템 탐색 및 이해 프로세스를 간소화하는 데 필수적입니다.`),we.forEach(t),g=n(e),S=s(e,"H2",{id:!0});var Le=a(S);w=s(Le,"A",{href:!0});var ke=a(w);K=s(ke,"STRONG",{});var Ce=a(K);me=i(Ce,"인코딩 방지"),Ce.forEach(t),ke.forEach(t),Le.forEach(t),ee=n(e),L=s(e,"P",{});var De=a(L);ne=i(De,`인코딩, 즉 이름에 유형이나 범위 정보를 삽입하는 관행은 더 이상 최신 코더에 제공되지 않는 과거 프로그래밍 관행의 흔적입니다. 의미 있는 이름 지정은 가독성과 단순성을 위해 이러한 인코딩을 피하고 코드의 의도를
모호하게 하지 않으면서 코드의 구조와 이름 지정 규칙이 필요한 컨텍스트를 제공할 수 있도록 합니다.`),De.forEach(t),te=n(e),G=s(e,"H2",{id:!0});var ze=a(G);k=s(ze,"A",{href:!0});var Be=a(k);M=s(Be,"STRONG",{});var Fe=a(M);Ee=i(Fe,"이름에 담긴 기억과 유머"),Fe.forEach(t),Be.forEach(t),ze.forEach(t),fe=n(e),C=s(e,"P",{});var Ie=a(C);he=i(Ie,`자신의 기억이나 유머 감각에 의존하여 이름을 짓는 것은 유혹적일 수 있지만 종종 혼란과 배제로 이어집니다. 너무 비밀스럽거나 내부 농담이 담긴 이름은 새로운 팀 구성원이나 향후 코드 관리자를 소외시킬 수 있습니다.
따라서 보편적으로 이해할 수 있는 이름을 선택하여 코드 자체가 표현되는 포괄적인 환경을 조성하는 것이 좋습니다.`),Ie.forEach(t),le=n(e),N=s(e,"H2",{id:!0});var Je=a(N);D=s(Je,"A",{href:!0});var Ke=a(D);Q=s(Ke,"STRONG",{});var Me=a(Q);de=i(Me,"방법론적 명명"),Me.forEach(t),Ke.forEach(t),Je.forEach(t),re=n(e),z=s(e,"P",{});var Qe=a(z);xe=i(Qe,`마지막으로, 명명에 대한 방법론적 접근 방식을 채택하는 것은 작업에 적합한 도구를 선택하는 것과 유사합니다. 여기에는 설명적이고 명확할 뿐만 아니라 프로젝트의 전반적인 명명 규칙과도 일치하는 이름을 선택하는 것이
포함됩니다. 이러한 체계적인 접근 방식을 통해 각 이름은 각 구성 요소의 목적과 기능이 즉시 드러나는 응집력 있고 탐색 가능한 코드베이스에 기여합니다.`),Qe.forEach(t),se=n(e),O=s(e,"H2",{id:!0});var Ue=a(O);B=s(Ue,"A",{href:!0});var Ve=a(B);U=s(Ve,"STRONG",{});var We=a(U);Pe=i(We,"결론"),We.forEach(t),Ve.forEach(t),Ue.forEach(t),ae=n(e),F=s(e,"P",{});var Xe=a(F);$e=i(Xe,`광범위한 소프트웨어 개발 환경에서 의미 있는 이름은 명확성과 이해의 기둥이 됩니다. 이 장에 설명된 원칙을 준수함으로써 개발자는 기능적일 뿐만 아니라 직관적이고 유지 관리가 가능한 코드를 만들 수 있습니다.
프로그래밍의 복잡성을 탐색하면서 코드의 세계에서 이름은 레이블 그 이상이며 이해를 위한 관문이라는 점을 기억하십시오.`),Xe.forEach(t),this.h()},h(){v(E,"href","#소프트웨어-개발에서-명명-기술이-가지는-의미"),v(_,"id","소프트웨어-개발에서-명명-기술이-가지는-의미"),v(T,"href","#의도를-분명히-밝히자"),v($,"id","의도를-분명히-밝히자"),v(c,"href","#의미-있게-구별하기"),v(A,"id","의미-있게-구별하기"),v(j,"href","#발음-및-검색-가능성"),v(H,"id","발음-및-검색-가능성"),v(w,"href","#인코딩-방지"),v(S,"id","인코딩-방지"),v(k,"href","#이름에-담긴-기억과-유머"),v(G,"id","이름에-담긴-기억과-유머"),v(D,"href","#방법론적-명명"),v(N,"id","방법론적-명명"),v(B,"href","#결론"),v(O,"id","결론")},m(e,f){l(e,_,f),o(_,E),o(E,d),l(e,x,f),l(e,u,f),o(u,h),l(e,P,f),l(e,$,f),o($,T),o(T,oe),l(e,V,f),l(e,y,f),o(y,_e),l(e,W,f),l(e,A,f),o(A,c),o(c,I),o(I,ue),l(e,X,f),l(e,b,f),o(b,pe),l(e,Y,f),l(e,H,f),o(H,j),o(j,J),o(J,ie),l(e,Z,f),l(e,q,f),o(q,ve),l(e,g,f),l(e,S,f),o(S,w),o(w,K),o(K,me),l(e,ee,f),l(e,L,f),o(L,ne),l(e,te,f),l(e,G,f),o(G,k),o(k,M),o(M,Ee),l(e,fe,f),l(e,C,f),o(C,he),l(e,le,f),l(e,N,f),o(N,D),o(D,Q),o(Q,de),l(e,re,f),l(e,z,f),o(z,xe),l(e,se,f),l(e,O,f),o(O,B),o(B,U),o(U,Pe),l(e,ae,f),l(e,F,f),o(F,$e)},p:pt,d(e){e&&t(_),e&&t(x),e&&t(u),e&&t(P),e&&t($),e&&t(V),e&&t(y),e&&t(W),e&&t(A),e&&t(X),e&&t(b),e&&t(Y),e&&t(H),e&&t(Z),e&&t(q),e&&t(g),e&&t(S),e&&t(ee),e&&t(L),e&&t(te),e&&t(G),e&&t(fe),e&&t(C),e&&t(le),e&&t(N),e&&t(re),e&&t(z),e&&t(se),e&&t(O),e&&t(ae),e&&t(F)}}}function mt(R){let _,E;const d=[R[0],ge];let x={$$slots:{default:[vt]},$$scope:{ctx:R}};for(let u=0;u<d.length;u+=1)x=Ae(x,d[u]);return _=new it({props:x}),{c(){lt(_.$$.fragment)},l(u){rt(_.$$.fragment,u)},m(u,h){st(_,u,h),E=!0},p(u,[h]){const P=h&1?at(d,[h&1&&Ye(u[0]),h&0&&Ye(ge)]):{};h&2&&(P.$$scope={dirty:h,ctx:u}),_.$set(P)},i(u){E||(ot(_.$$.fragment,u),E=!0)},o(u){_t(_.$$.fragment,u),E=!1},d(u){ut(_,u)}}}const ge={title:"2장 의미있는 이름",summary:"",date:"2024-01-02",published:!1};function nt(R,_,E){return R.$$set=d=>{E(0,_=Ae(Ae({},_),Ze(d)))},_=Ze(_),[_]}class dt extends et{constructor(_){super(),tt(this,_,nt,mt,ft,{})}}export{dt as component};
