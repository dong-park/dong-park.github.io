import{S as ie,i as ue,s as pe,U as jt,B as ve,C as Ee,D as me,V as he,W as _e,r as de,p as ce,E as Se,X as ne,e as r,t as i,a as p,c as s,b as o,d as u,f as e,g as v,m as d,h as a,j as l,n as Oe}from"./index.c0b9c16e.js";import{A as Te}from"./ArticleLayout.072337d2.js";function Ge($){let _,m,c,O,n,E,x,Y,T,A,U,_t,Z,b,nt,g,G,y,V,it,tt,H,ut,et,h,L,W,pt,vt,Et,j,X,mt,ht,dt,I,k,ct,St,Ot,C,F,Tt,Gt,lt,N,q,J,Nt,rt,w,Rt,st,R,z,K,Pt,ot,B,$t,ft,P,D,Q,xt,at,M,At;return{c(){_=r("h2"),m=r("a"),c=r("strong"),O=i("클린 코드: 소프트웨어 개발 속도를 높이는 관문"),n=p(),E=r("p"),x=i(`소프트웨어 개발 영역에서 효율성과 속도에 대한 탐구는 종종 역설적인 진실로 이어집니다. 즉, 개발 프로세스를 진정으로 가속화하는 유일한 방법은 코드의 청결성을 유지하는 것입니다. 클린 코드 철학의 핵심인 이 원칙은
속도와 코드 품질이 상충되는 이해관계가 아니라 오히려 동일한 목표의 보완적인 측면임을 강조합니다.`),Y=p(),T=r("h3"),A=r("a"),U=r("strong"),_t=i("클린 코드의 기초"),Z=p(),b=r("p"),nt=i(`클린 코드의 핵심은 단순히 작동하는 코드를 작성하는 것 이상입니다. 원저작자가 아닌 다른 사람도 쉽게 읽고, 이해하고, 수정할 수 있는 코드를 만드는 것입니다. 이 개념은 해당 주제에 관한 문헌의 주목할만한 주장으로
우아하게 요약되어 있습니다. “빠르게 진행하는 유일한 방법은 항상 코드를 깨끗하게 유지하는 것입니다.” 이 선언문은 개발자에게 지침이 되어 프로젝트의 효율성과 효율성을 높이는 경로로서 코드의 청결성을
우선시하도록 촉구합니다.`),g=p(),G=r("h3"),y=r("a"),V=r("strong"),it=i("클린 코드 구현: 4단계 접근 방식"),tt=p(),H=r("p"),ut=i("클린 코드를 향한 여정은 구현을 위한 네 가지 간단한 규칙을 채택하는 것부터 시작할 수 있습니다."),et=p(),h=r("ol"),L=r("li"),W=r("strong"),pt=i("모든 테스트 통과:"),vt=i(` 코드가 모든 테스트를 일관되게 통과하는지 확인하는 것이 청결을 향한 첫 번째 단계입니다. 이는 코드가 기능적 요구 사항을 충족할 뿐만 아니라 개발 팀이 정한 품질 표준을 준수함을
보장합니다.`),Et=p(),j=r("li"),X=r("strong"),mt=i("중복 금지:"),ht=i(" 중복은 클린 코드의 적입니다. 중복된 코드 조각을 피하면 코드베이스를 보다 쉽게 관리할 수 있을 뿐만 아니라 오류 및 불일치 가능성도 줄어듭니다."),dt=p(),I=r("li"),k=r("strong"),ct=i("시스템 내에서 모든 디자인 아이디어 표현:"),St=i(" 클린 코드는 디자인 의도를 효과적으로 전달하므로 미래의 개발자가 특정 구현의 근거와 전체 시스템 아키텍처에 어떻게 적용되는지 더 쉽게 이해할 수 있습니다."),Ot=p(),C=r("li"),F=r("strong"),Tt=i("클래스, 메서드, 함수 등의 수를 최소화하세요."),Gt=i(" 단순화가 핵심입니다. 코드의 복잡성을 줄임으로써 개발자는 코드의 가독성과 유지 관리성을 향상시켜 더 쉽게 업데이트하고 수정할 수 있습니다."),lt=p(),N=r("h3"),q=r("a"),J=r("strong"),Nt=i("캠프장의 규칙: 처음 찾은 것보다 코드베이스를 더 좋게 남겨두기"),rt=p(),w=r("p"),Rt=i(`클린 코드의 필수 정신은 “캠프장을 처음 도착했을 때보다 깨끗하게 유지하세요”라는 조언에 요약되어 있습니다. 이 은유적 지침은 개발자가 작업하는 코드를 지속적으로 개선하고 개선하여 각 기여가 가치를 더할 뿐만 아니라
코드베이스의 전반적인 품질을 향상시키도록 장려합니다. 이러한 접근 방식은 청결과 효율성을 지속적으로 우선시하는 지속적인 개선 문화를 조성합니다.`),st=p(),R=r("h3"),z=r("a"),K=r("strong"),Pt=i("청결을 향한 끝없는 여정"),ot=p(),B=r("p"),$t=i(`깨끗한 코드를 달성하기 위해 설명된 명확한 경로와 원칙에도 불구하고 여정은 계속 진행 중입니다. 본문에는 “클린코드에 대한 끝없는 고민은 정리하고 계속 정리하는 방법인데 왕도는 없는 것 같다. 그냥 청소를 쉽게
해주는 패턴이 있는 것 같다”고 인정하고 있다. 이 성찰은 더 깔끔한 코드를 촉진하는 전략과 관행이 있지만 프로세스에는 지속적인 경계와 노력이 필요하다는 점을 강조합니다. 청결에 대한 단일 솔루션이나 “왕도”는
없습니다. 이는 학습하고, 적응하고, 개선하는 지속적인 과정입니다.`),ft=p(),P=r("h3"),D=r("a"),Q=r("strong"),xt=i("결론"),at=p(),M=r("p"),At=i(`클린 코드는 효율적이고 지속 가능한 소프트웨어 개발의 초석입니다. 간단한 규칙을 준수하고, 지속적인 개선 정신을 수용하고, 여정의 지속적인 성격을 인식함으로써 개발자는 코드가 깨끗하고 효율적이며 미래에도 대비할 수
있도록 보장할 수 있습니다. 이 접근 방식은 개발 프로세스를 가속화할 뿐만 아니라 코드베이스가 시간이 지나도 강력하고 적응 가능하며 유지 관리하기 쉬운 상태로 유지되도록 보장합니다. 끊임없이 진화하는 소프트웨어 개발
환경에서 클린 코드는 개발자가 더 좋고, 더 빠르고, 더 안정적인 소프트웨어 솔루션을 구축할 수 있도록 지원하는 기본 원칙으로 두드러집니다.`),this.h()},l(t){_=s(t,"H2",{id:!0});var f=o(_);m=s(f,"A",{href:!0});var Ct=o(m);c=s(Ct,"STRONG",{});var qt=o(c);O=u(qt,"클린 코드: 소프트웨어 개발 속도를 높이는 관문"),qt.forEach(e),Ct.forEach(e),f.forEach(e),n=v(t),E=s(t,"P",{});var wt=o(E);x=u(wt,`소프트웨어 개발 영역에서 효율성과 속도에 대한 탐구는 종종 역설적인 진실로 이어집니다. 즉, 개발 프로세스를 진정으로 가속화하는 유일한 방법은 코드의 청결성을 유지하는 것입니다. 클린 코드 철학의 핵심인 이 원칙은
속도와 코드 품질이 상충되는 이해관계가 아니라 오히려 동일한 목표의 보완적인 측면임을 강조합니다.`),wt.forEach(e),Y=v(t),T=s(t,"H3",{id:!0});var zt=o(T);A=s(zt,"A",{href:!0});var Bt=o(A);U=s(Bt,"STRONG",{});var Dt=o(U);_t=u(Dt,"클린 코드의 기초"),Dt.forEach(e),Bt.forEach(e),zt.forEach(e),Z=v(t),b=s(t,"P",{});var Mt=o(b);nt=u(Mt,`클린 코드의 핵심은 단순히 작동하는 코드를 작성하는 것 이상입니다. 원저작자가 아닌 다른 사람도 쉽게 읽고, 이해하고, 수정할 수 있는 코드를 만드는 것입니다. 이 개념은 해당 주제에 관한 문헌의 주목할만한 주장으로
우아하게 요약되어 있습니다. “빠르게 진행하는 유일한 방법은 항상 코드를 깨끗하게 유지하는 것입니다.” 이 선언문은 개발자에게 지침이 되어 프로젝트의 효율성과 효율성을 높이는 경로로서 코드의 청결성을
우선시하도록 촉구합니다.`),Mt.forEach(e),g=v(t),G=s(t,"H3",{id:!0});var Ut=o(G);y=s(Ut,"A",{href:!0});var Vt=o(y);V=s(Vt,"STRONG",{});var Wt=o(V);it=u(Wt,"클린 코드 구현: 4단계 접근 방식"),Wt.forEach(e),Vt.forEach(e),Ut.forEach(e),tt=v(t),H=s(t,"P",{});var Xt=o(H);ut=u(Xt,"클린 코드를 향한 여정은 구현을 위한 네 가지 간단한 규칙을 채택하는 것부터 시작할 수 있습니다."),Xt.forEach(e),et=v(t),h=s(t,"OL",{});var S=o(h);L=s(S,"LI",{});var bt=o(L);W=s(bt,"STRONG",{});var kt=o(W);pt=u(kt,"모든 테스트 통과:"),kt.forEach(e),vt=u(bt,` 코드가 모든 테스트를 일관되게 통과하는지 확인하는 것이 청결을 향한 첫 번째 단계입니다. 이는 코드가 기능적 요구 사항을 충족할 뿐만 아니라 개발 팀이 정한 품질 표준을 준수함을
보장합니다.`),bt.forEach(e),Et=v(S),j=s(S,"LI",{});var yt=o(j);X=s(yt,"STRONG",{});var Ft=o(X);mt=u(Ft,"중복 금지:"),Ft.forEach(e),ht=u(yt," 중복은 클린 코드의 적입니다. 중복된 코드 조각을 피하면 코드베이스를 보다 쉽게 관리할 수 있을 뿐만 아니라 오류 및 불일치 가능성도 줄어듭니다."),yt.forEach(e),dt=v(S),I=s(S,"LI",{});var Ht=o(I);k=s(Ht,"STRONG",{});var Jt=o(k);ct=u(Jt,"시스템 내에서 모든 디자인 아이디어 표현:"),Jt.forEach(e),St=u(Ht," 클린 코드는 디자인 의도를 효과적으로 전달하므로 미래의 개발자가 특정 구현의 근거와 전체 시스템 아키텍처에 어떻게 적용되는지 더 쉽게 이해할 수 있습니다."),Ht.forEach(e),Ot=v(S),C=s(S,"LI",{});var Lt=o(C);F=s(Lt,"STRONG",{});var Kt=o(F);Tt=u(Kt,"클래스, 메서드, 함수 등의 수를 최소화하세요."),Kt.forEach(e),Gt=u(Lt," 단순화가 핵심입니다. 코드의 복잡성을 줄임으로써 개발자는 코드의 가독성과 유지 관리성을 향상시켜 더 쉽게 업데이트하고 수정할 수 있습니다."),Lt.forEach(e),S.forEach(e),lt=v(t),N=s(t,"H3",{id:!0});var Qt=o(N);q=s(Qt,"A",{href:!0});var Yt=o(q);J=s(Yt,"STRONG",{});var Zt=o(J);Nt=u(Zt,"캠프장의 규칙: 처음 찾은 것보다 코드베이스를 더 좋게 남겨두기"),Zt.forEach(e),Yt.forEach(e),Qt.forEach(e),rt=v(t),w=s(t,"P",{});var gt=o(w);Rt=u(gt,`클린 코드의 필수 정신은 “캠프장을 처음 도착했을 때보다 깨끗하게 유지하세요”라는 조언에 요약되어 있습니다. 이 은유적 지침은 개발자가 작업하는 코드를 지속적으로 개선하고 개선하여 각 기여가 가치를 더할 뿐만 아니라
코드베이스의 전반적인 품질을 향상시키도록 장려합니다. 이러한 접근 방식은 청결과 효율성을 지속적으로 우선시하는 지속적인 개선 문화를 조성합니다.`),gt.forEach(e),st=v(t),R=s(t,"H3",{id:!0});var te=o(R);z=s(te,"A",{href:!0});var ee=o(z);K=s(ee,"STRONG",{});var le=o(K);Pt=u(le,"청결을 향한 끝없는 여정"),le.forEach(e),ee.forEach(e),te.forEach(e),ot=v(t),B=s(t,"P",{});var re=o(B);$t=u(re,`깨끗한 코드를 달성하기 위해 설명된 명확한 경로와 원칙에도 불구하고 여정은 계속 진행 중입니다. 본문에는 “클린코드에 대한 끝없는 고민은 정리하고 계속 정리하는 방법인데 왕도는 없는 것 같다. 그냥 청소를 쉽게
해주는 패턴이 있는 것 같다”고 인정하고 있다. 이 성찰은 더 깔끔한 코드를 촉진하는 전략과 관행이 있지만 프로세스에는 지속적인 경계와 노력이 필요하다는 점을 강조합니다. 청결에 대한 단일 솔루션이나 “왕도”는
없습니다. 이는 학습하고, 적응하고, 개선하는 지속적인 과정입니다.`),re.forEach(e),ft=v(t),P=s(t,"H3",{id:!0});var se=o(P);D=s(se,"A",{href:!0});var oe=o(D);Q=s(oe,"STRONG",{});var fe=o(Q);xt=u(fe,"결론"),fe.forEach(e),oe.forEach(e),se.forEach(e),at=v(t),M=s(t,"P",{});var ae=o(M);At=u(ae,`클린 코드는 효율적이고 지속 가능한 소프트웨어 개발의 초석입니다. 간단한 규칙을 준수하고, 지속적인 개선 정신을 수용하고, 여정의 지속적인 성격을 인식함으로써 개발자는 코드가 깨끗하고 효율적이며 미래에도 대비할 수
있도록 보장할 수 있습니다. 이 접근 방식은 개발 프로세스를 가속화할 뿐만 아니라 코드베이스가 시간이 지나도 강력하고 적응 가능하며 유지 관리하기 쉬운 상태로 유지되도록 보장합니다. 끊임없이 진화하는 소프트웨어 개발
환경에서 클린 코드는 개발자가 더 좋고, 더 빠르고, 더 안정적인 소프트웨어 솔루션을 구축할 수 있도록 지원하는 기본 원칙으로 두드러집니다.`),ae.forEach(e),this.h()},h(){d(m,"href","#클린-코드-소프트웨어-개발-속도를-높이는-관문"),d(_,"id","클린-코드-소프트웨어-개발-속도를-높이는-관문"),d(A,"href","#클린-코드의-기초"),d(T,"id","클린-코드의-기초"),d(y,"href","#클린-코드-구현-4단계-접근-방식"),d(G,"id","클린-코드-구현-4단계-접근-방식"),d(q,"href","#캠프장의-규칙-처음-찾은-것보다-코드베이스를-더-좋게-남겨두기"),d(N,"id","캠프장의-규칙-처음-찾은-것보다-코드베이스를-더-좋게-남겨두기"),d(z,"href","#청결을-향한-끝없는-여정"),d(R,"id","청결을-향한-끝없는-여정"),d(D,"href","#결론"),d(P,"id","결론")},m(t,f){a(t,_,f),l(_,m),l(m,c),l(c,O),a(t,n,f),a(t,E,f),l(E,x),a(t,Y,f),a(t,T,f),l(T,A),l(A,U),l(U,_t),a(t,Z,f),a(t,b,f),l(b,nt),a(t,g,f),a(t,G,f),l(G,y),l(y,V),l(V,it),a(t,tt,f),a(t,H,f),l(H,ut),a(t,et,f),a(t,h,f),l(h,L),l(L,W),l(W,pt),l(L,vt),l(h,Et),l(h,j),l(j,X),l(X,mt),l(j,ht),l(h,dt),l(h,I),l(I,k),l(k,ct),l(I,St),l(h,Ot),l(h,C),l(C,F),l(F,Tt),l(C,Gt),a(t,lt,f),a(t,N,f),l(N,q),l(q,J),l(J,Nt),a(t,rt,f),a(t,w,f),l(w,Rt),a(t,st,f),a(t,R,f),l(R,z),l(z,K),l(K,Pt),a(t,ot,f),a(t,B,f),l(B,$t),a(t,ft,f),a(t,P,f),l(P,D),l(D,Q),l(Q,xt),a(t,at,f),a(t,M,f),l(M,At)},p:Oe,d(t){t&&e(_),t&&e(n),t&&e(E),t&&e(Y),t&&e(T),t&&e(Z),t&&e(b),t&&e(g),t&&e(G),t&&e(tt),t&&e(H),t&&e(et),t&&e(h),t&&e(lt),t&&e(N),t&&e(rt),t&&e(w),t&&e(st),t&&e(R),t&&e(ot),t&&e(B),t&&e(ft),t&&e(P),t&&e(at),t&&e(M)}}}function Ne($){let _,m;const c=[$[0],It];let O={$$slots:{default:[Ge]},$$scope:{ctx:$}};for(let n=0;n<c.length;n+=1)O=jt(O,c[n]);return _=new Te({props:O}),{c(){ve(_.$$.fragment)},l(n){Ee(_.$$.fragment,n)},m(n,E){me(_,n,E),m=!0},p(n,[E]){const x=E&1?he(c,[E&1&&_e(n[0]),E&0&&_e(It)]):{};E&2&&(x.$$scope={dirty:E,ctx:n}),_.$set(x)},i(n){m||(de(_.$$.fragment,n),m=!0)},o(n){ce(_.$$.fragment,n),m=!1},d(n){Se(_,n)}}}const It={title:"1장 깨끗한 코드",summary:"",date:"2024-01-01",published:!1};function Re($,_,m){return $.$$set=c=>{m(0,_=jt(jt({},_),ne(c)))},_=ne(_),[_]}class Pe extends ie{constructor(_){super(),ue(this,_,Re,Ne,pe,{})}}const Ae=Object.freeze(Object.defineProperty({__proto__:null,default:Pe,metadata:It},Symbol.toStringTag,{value:"Module"}));export{Pe as P,Ae as _};
