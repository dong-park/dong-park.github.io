import{S as be,i as ye,s as He,U as Qt,B as Ie,C as je,D as Ue,V as Ce,W as xe,r as qe,p as we,E as ze,X as Ae,e as r,t as _,a as v,c as s,b as o,d as i,f as e,g as p,m,h as a,j as l,n as Be}from"./index.c0b9c16e.js";import{A as De}from"./ArticleLayout.072337d2.js";function Me(L){let n,d,c,h,u,E,$,st,x,dt,ot,T,A,F,ct,ft,b,St,at,G,y,J,Ot,_t,H,Tt,it,N,I,K,Gt,nt,j,Nt,ut,S,U,Q,Rt,Pt,Lt,C,Y,$t,xt,At,q,Z,bt,yt,vt,R,w,g,Ht,pt,z,It,Et,O,B,tt,jt,Ut,Ct,D,et,qt,wt,zt,M,lt,Bt,Dt,mt,P,V,rt,Mt,ht,W,Vt;return{c(){n=r("p"),d=_(`코드의 주석은 양날의 검 역할을 합니다. 귀중한 통찰력과 설명을 제공할 수 있지만 오해를 불러일으키거나 혼란을 야기할 가능성도 있습니다. 이 장에서는 코드와 주석 사이의 복잡한 관계를 탐구하고 코드의 명확성과 의도를
모호하게 하기보다는 향상시키는 관행을 옹호합니다.`),c=v(),h=r("h3"),u=r("a"),E=r("strong"),$=_("코드의 진실"),st=v(),x=r("p"),dt=_(`소프트웨어 개발의 핵심에는 단순한 진실이 있습니다. 즉, 코드 자체가 소프트웨어가 수행하는 작업의 최종 소스입니다. 주석은 의도가 좋은 경우가 많지만 코드 실행을 변경할 수 없으며 코드가 발전함에 따라 오래되거나
부정확해질 수 있습니다. 코드를 진실의 단일 소스로 인식하면 개발자는 프로그래밍 방식에서 명확성과 정확성을 우선시하게 됩니다.`),ot=v(),T=r("h3"),A=r("a"),F=r("strong"),ct=_("주석과 잘못된 코드"),ft=v(),b=r("p"),St=_(`복잡하거나 불분명한 코드의 단점을 광범위한 주석으로 해결할 수 있다는 것은 일반적인 오해입니다. 그러나 이해하기 위해 주석에 크게 의존하는 코드베이스는 더 깊은 문제의 징후입니다. 설명의 필요성을 최소화하는 표현력
있고 잘 구조화된 코드는 변함없이 선호되며 깔끔한 코딩 관행의 중요성을 강조합니다.`),at=v(),G=r("h3"),y=r("a"),J=r("strong"),Ot=_("표현적 코드"),_t=v(),H=r("p"),Tt=_(`효과적인 코딩의 핵심은 구조와 명명 규칙을 통해 의도를 직접 전달하는 능력에 있습니다. 코드를 명확하게 작성하면 주석의 필요성이 줄어듭니다. 설명을 자명한 함수나 변수로 변환하면 추가 설명이 필요하지 않아 코드가
간소화되고 가독성과 유지 관리성이 향상되는 경우가 많습니다.`),it=v(),N=r("h3"),I=r("a"),K=r("strong"),Gt=_("좋은주석의 가치"),nt=v(),j=r("p"),Nt=_("목표는 주석에 대한 의존도를 최소화하는 것이지만 다음과 같은 특정 유형의 댓글은 매우 중요합니다."),ut=v(),S=r("ul"),U=r("li"),Q=r("strong"),Rt=_("법적 및 저작권 참고 사항"),Pt=_(": 지적 재산권을 보호하고 사용 권한을 명확히 하는 데 필수적입니다."),Lt=v(),C=r("li"),Y=r("strong"),$t=_("정보 주석"),xt=_(": 특히 코드 제약 조건이 있는 경우 컨텍스트를 제공하거나 특정 결정의 근거를 설명합니다."),At=v(),q=r("li"),Z=r("strong"),bt=_("의도 및 설명"),yt=_(": 코드가 존재하는 이유를 설명하거나 복잡한 논리를 명확히 하는 설명은 특히 외부 라이브러리나 피할 수 없는 복잡성을 처리할 때 도움이 될 수 있습니다."),vt=v(),R=r("h3"),w=r("a"),g=r("strong"),Ht=_("안좋은 주석의 함정"),pt=v(),z=r("p"),It=_("반대로, 많은 주석은 코드의 품질과 가독성을 떨어뜨립니다. 예는 다음과 같습니다:"),Et=v(),O=r("ul"),B=r("li"),tt=r("strong"),jt=_("중복되거나 오해의 소지가 있는 주석"),Ut=_(": 명백한 내용을 다시 설명하거나 부정확한 내용을 포함하는 댓글은 도움이 되기보다는 해로울 수 있습니다."),Ct=v(),D=r("li"),et=r("strong"),qt=_("오래되었거나 오래된 정보"),wt=_(": 설명하는 코드와 함께 유지 관리되지 않은 주석은 혼란을 야기합니다."),zt=v(),M=r("li"),lt=r("strong"),Bt=_("주석 처리된 코드"),Dt=_(": 코드베이스를 복잡하게 만드는 일반적인 나쁜 습관으로, 버전 제어 시스템에 대한 신뢰도가 부족함을 나타냅니다."),mt=v(),P=r("h3"),V=r("a"),rt=r("strong"),Mt=_("결론"),ht=v(),W=r("p"),Vt=_(`코드의 주석은 미묘한 공간을 차지하므로 의도를 명확히 하고 이해를 혼란스럽게 할 수 있습니다. 지침 원칙은 코드만으로는 충분하지 않은 곳에 가치를 추가하기 위해 주석을 아껴서 신중하게 사용하여 가능한 한 설명이 필요
없는 코드를 작성하는 것입니다. 코드의 명확성과 표현력을 우선시하는 방식을 채택함으로써 개발자는 주석에 대한 의존도를 줄여 더 깔끔하고 유지 관리하기 쉬운 코드베이스를 만들 수 있습니다.`),this.h()},l(t){n=s(t,"P",{});var f=o(n);d=i(f,`코드의 주석은 양날의 검 역할을 합니다. 귀중한 통찰력과 설명을 제공할 수 있지만 오해를 불러일으키거나 혼란을 야기할 가능성도 있습니다. 이 장에서는 코드와 주석 사이의 복잡한 관계를 탐구하고 코드의 명확성과 의도를
모호하게 하기보다는 향상시키는 관행을 옹호합니다.`),f.forEach(e),c=p(t),h=s(t,"H3",{id:!0});var Zt=o(h);u=s(Zt,"A",{href:!0});var gt=o(u);E=s(gt,"STRONG",{});var te=o(E);$=i(te,"코드의 진실"),te.forEach(e),gt.forEach(e),Zt.forEach(e),st=p(t),x=s(t,"P",{});var ee=o(x);dt=i(ee,`소프트웨어 개발의 핵심에는 단순한 진실이 있습니다. 즉, 코드 자체가 소프트웨어가 수행하는 작업의 최종 소스입니다. 주석은 의도가 좋은 경우가 많지만 코드 실행을 변경할 수 없으며 코드가 발전함에 따라 오래되거나
부정확해질 수 있습니다. 코드를 진실의 단일 소스로 인식하면 개발자는 프로그래밍 방식에서 명확성과 정확성을 우선시하게 됩니다.`),ee.forEach(e),ot=p(t),T=s(t,"H3",{id:!0});var le=o(T);A=s(le,"A",{href:!0});var re=o(A);F=s(re,"STRONG",{});var se=o(F);ct=i(se,"주석과 잘못된 코드"),se.forEach(e),re.forEach(e),le.forEach(e),ft=p(t),b=s(t,"P",{});var oe=o(b);St=i(oe,`복잡하거나 불분명한 코드의 단점을 광범위한 주석으로 해결할 수 있다는 것은 일반적인 오해입니다. 그러나 이해하기 위해 주석에 크게 의존하는 코드베이스는 더 깊은 문제의 징후입니다. 설명의 필요성을 최소화하는 표현력
있고 잘 구조화된 코드는 변함없이 선호되며 깔끔한 코딩 관행의 중요성을 강조합니다.`),oe.forEach(e),at=p(t),G=s(t,"H3",{id:!0});var fe=o(G);y=s(fe,"A",{href:!0});var ae=o(y);J=s(ae,"STRONG",{});var _e=o(J);Ot=i(_e,"표현적 코드"),_e.forEach(e),ae.forEach(e),fe.forEach(e),_t=p(t),H=s(t,"P",{});var ie=o(H);Tt=i(ie,`효과적인 코딩의 핵심은 구조와 명명 규칙을 통해 의도를 직접 전달하는 능력에 있습니다. 코드를 명확하게 작성하면 주석의 필요성이 줄어듭니다. 설명을 자명한 함수나 변수로 변환하면 추가 설명이 필요하지 않아 코드가
간소화되고 가독성과 유지 관리성이 향상되는 경우가 많습니다.`),ie.forEach(e),it=p(t),N=s(t,"H3",{id:!0});var ne=o(N);I=s(ne,"A",{href:!0});var ue=o(I);K=s(ue,"STRONG",{});var ve=o(K);Gt=i(ve,"좋은주석의 가치"),ve.forEach(e),ue.forEach(e),ne.forEach(e),nt=p(t),j=s(t,"P",{});var pe=o(j);Nt=i(pe,"목표는 주석에 대한 의존도를 최소화하는 것이지만 다음과 같은 특정 유형의 댓글은 매우 중요합니다."),pe.forEach(e),ut=p(t),S=s(t,"UL",{});var X=o(S);U=s(X,"LI",{});var Wt=o(U);Q=s(Wt,"STRONG",{});var Ee=o(Q);Rt=i(Ee,"법적 및 저작권 참고 사항"),Ee.forEach(e),Pt=i(Wt,": 지적 재산권을 보호하고 사용 권한을 명확히 하는 데 필수적입니다."),Wt.forEach(e),Lt=p(X),C=s(X,"LI",{});var Xt=o(C);Y=s(Xt,"STRONG",{});var me=o(Y);$t=i(me,"정보 주석"),me.forEach(e),xt=i(Xt,": 특히 코드 제약 조건이 있는 경우 컨텍스트를 제공하거나 특정 결정의 근거를 설명합니다."),Xt.forEach(e),At=p(X),q=s(X,"LI",{});var kt=o(q);Z=s(kt,"STRONG",{});var he=o(Z);bt=i(he,"의도 및 설명"),he.forEach(e),yt=i(kt,": 코드가 존재하는 이유를 설명하거나 복잡한 논리를 명확히 하는 설명은 특히 외부 라이브러리나 피할 수 없는 복잡성을 처리할 때 도움이 될 수 있습니다."),kt.forEach(e),X.forEach(e),vt=p(t),R=s(t,"H3",{id:!0});var de=o(R);w=s(de,"A",{href:!0});var ce=o(w);g=s(ce,"STRONG",{});var Se=o(g);Ht=i(Se,"안좋은 주석의 함정"),Se.forEach(e),ce.forEach(e),de.forEach(e),pt=p(t),z=s(t,"P",{});var Oe=o(z);It=i(Oe,"반대로, 많은 주석은 코드의 품질과 가독성을 떨어뜨립니다. 예는 다음과 같습니다:"),Oe.forEach(e),Et=p(t),O=s(t,"UL",{});var k=o(O);B=s(k,"LI",{});var Ft=o(B);tt=s(Ft,"STRONG",{});var Te=o(tt);jt=i(Te,"중복되거나 오해의 소지가 있는 주석"),Te.forEach(e),Ut=i(Ft,": 명백한 내용을 다시 설명하거나 부정확한 내용을 포함하는 댓글은 도움이 되기보다는 해로울 수 있습니다."),Ft.forEach(e),Ct=p(k),D=s(k,"LI",{});var Jt=o(D);et=s(Jt,"STRONG",{});var Ge=o(et);qt=i(Ge,"오래되었거나 오래된 정보"),Ge.forEach(e),wt=i(Jt,": 설명하는 코드와 함께 유지 관리되지 않은 주석은 혼란을 야기합니다."),Jt.forEach(e),zt=p(k),M=s(k,"LI",{});var Kt=o(M);lt=s(Kt,"STRONG",{});var Ne=o(lt);Bt=i(Ne,"주석 처리된 코드"),Ne.forEach(e),Dt=i(Kt,": 코드베이스를 복잡하게 만드는 일반적인 나쁜 습관으로, 버전 제어 시스템에 대한 신뢰도가 부족함을 나타냅니다."),Kt.forEach(e),k.forEach(e),mt=p(t),P=s(t,"H3",{id:!0});var Re=o(P);V=s(Re,"A",{href:!0});var Pe=o(V);rt=s(Pe,"STRONG",{});var Le=o(rt);Mt=i(Le,"결론"),Le.forEach(e),Pe.forEach(e),Re.forEach(e),ht=p(t),W=s(t,"P",{});var $e=o(W);Vt=i($e,`코드의 주석은 미묘한 공간을 차지하므로 의도를 명확히 하고 이해를 혼란스럽게 할 수 있습니다. 지침 원칙은 코드만으로는 충분하지 않은 곳에 가치를 추가하기 위해 주석을 아껴서 신중하게 사용하여 가능한 한 설명이 필요
없는 코드를 작성하는 것입니다. 코드의 명확성과 표현력을 우선시하는 방식을 채택함으로써 개발자는 주석에 대한 의존도를 줄여 더 깔끔하고 유지 관리하기 쉬운 코드베이스를 만들 수 있습니다.`),$e.forEach(e),this.h()},h(){m(u,"href","#코드의-진실"),m(h,"id","코드의-진실"),m(A,"href","#주석과-잘못된-코드"),m(T,"id","주석과-잘못된-코드"),m(y,"href","#표현적-코드"),m(G,"id","표현적-코드"),m(I,"href","#좋은주석의-가치"),m(N,"id","좋은주석의-가치"),m(w,"href","#안좋은-주석의-함정"),m(R,"id","안좋은-주석의-함정"),m(V,"href","#결론"),m(P,"id","결론")},m(t,f){a(t,n,f),l(n,d),a(t,c,f),a(t,h,f),l(h,u),l(u,E),l(E,$),a(t,st,f),a(t,x,f),l(x,dt),a(t,ot,f),a(t,T,f),l(T,A),l(A,F),l(F,ct),a(t,ft,f),a(t,b,f),l(b,St),a(t,at,f),a(t,G,f),l(G,y),l(y,J),l(J,Ot),a(t,_t,f),a(t,H,f),l(H,Tt),a(t,it,f),a(t,N,f),l(N,I),l(I,K),l(K,Gt),a(t,nt,f),a(t,j,f),l(j,Nt),a(t,ut,f),a(t,S,f),l(S,U),l(U,Q),l(Q,Rt),l(U,Pt),l(S,Lt),l(S,C),l(C,Y),l(Y,$t),l(C,xt),l(S,At),l(S,q),l(q,Z),l(Z,bt),l(q,yt),a(t,vt,f),a(t,R,f),l(R,w),l(w,g),l(g,Ht),a(t,pt,f),a(t,z,f),l(z,It),a(t,Et,f),a(t,O,f),l(O,B),l(B,tt),l(tt,jt),l(B,Ut),l(O,Ct),l(O,D),l(D,et),l(et,qt),l(D,wt),l(O,zt),l(O,M),l(M,lt),l(lt,Bt),l(M,Dt),a(t,mt,f),a(t,P,f),l(P,V),l(V,rt),l(rt,Mt),a(t,ht,f),a(t,W,f),l(W,Vt)},p:Be,d(t){t&&e(n),t&&e(c),t&&e(h),t&&e(st),t&&e(x),t&&e(ot),t&&e(T),t&&e(ft),t&&e(b),t&&e(at),t&&e(G),t&&e(_t),t&&e(H),t&&e(it),t&&e(N),t&&e(nt),t&&e(j),t&&e(ut),t&&e(S),t&&e(vt),t&&e(R),t&&e(pt),t&&e(z),t&&e(Et),t&&e(O),t&&e(mt),t&&e(P),t&&e(ht),t&&e(W)}}}function Ve(L){let n,d;const c=[L[0],Yt];let h={$$slots:{default:[Me]},$$scope:{ctx:L}};for(let u=0;u<c.length;u+=1)h=Qt(h,c[u]);return n=new De({props:h}),{c(){Ie(n.$$.fragment)},l(u){je(n.$$.fragment,u)},m(u,E){Ue(n,u,E),d=!0},p(u,[E]){const $=E&1?Ce(c,[E&1&&xe(u[0]),E&0&&xe(Yt)]):{};E&2&&($.$$scope={dirty:E,ctx:u}),n.$set($)},i(u){d||(qe(n.$$.fragment,u),d=!0)},o(u){we(n.$$.fragment,u),d=!1},d(u){ze(n,u)}}}const Yt={title:"4장 주석",summary:"",date:"2024-01-12",published:!1};function We(L,n,d){return L.$$set=c=>{d(0,n=Qt(Qt({},n),Ae(c)))},n=Ae(n),[n]}class Xe extends be{constructor(n){super(),ye(this,n,We,Ve,He,{})}}const Je=Object.freeze(Object.defineProperty({__proto__:null,default:Xe,metadata:Yt},Symbol.toStringTag,{value:"Module"}));export{Xe as P,Je as _};
