---
title: 2. Sort
summary: 정렬 알고리즘인 선택 정렬, 삽입 정렬, 버블 정렬에 대해 설명합니다. 선택 정렬은 O(N^2)의 시간 복잡도를 가지며, 비교 연산이 중요합니다. 삽입 정렬은 거의 정렬된 배열에서 효율적이며, 최선의 경우 O(N)입니다. 버블 정렬은 구현이 간단하지만 성능이 낮고, 최악의 경우 O(N^2)입니다. 세 가지 알고리즘의 성능을 비교하고 각 알고리즘의 사용 사례를 제시합니다.
date: '2024-10-03'
tags: ['']
---

# 2.1 Elementary Sorts

정렬은 컴퓨터 과학에서 매우 중요한 작업 중 하나로, 데이터를 순서대로 정렬하는 알고리즘 입니다. 이 강의에서는 가장 기본적인 정렬 알고리즘인 선택정렬, 삽입정렬, 그리고 버블 정렬에 대해 배웁니다.

이 알고리즘들은 이해하기 쉽고, 작은 데이터셋에 사용할 수 있습니다. 그러나 큰 데이터셋에서는 비효율적인 수 있습니다.

## 선택정렬

선택 정렬은 배열에서 가장 작은 항목을 찾아 첫 번째 위치에 놓고, 그다음 작은 항목을 찾아 두 번째 위치에 놓는 과정을 반복하여 배열을 정렬합니다.

### 선택 정렬의 과정

1. 배열에서 가장 작은 요소를 찾습니다.
2. 그 요소를 첫 번째 요소와 교환합니다.
3. 그다음 작은 요소를 찾고, 두 번째 요소와 교환합니다.
4. 이 과정을 반복하여 배열 전체를 정렬합니다.

### 선택 정렬의 구현

```java
public class SelectionSort {
	public static void sort(int[] arr) {
		int N = arr.length;
		for (int i=0; i<N; i++){
			int min = i;
			for (int j = i+1; j<N; j++) {
				if (arr[j] < arr[min]) {
					min = j;
				}
			}
		}
	}
	
	private static void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
}
```

### 선택 정렬 설명:

- 시간 복잡도: 선택 정렬의 시간 복잡도는 항상 O(N^2)입니다. N개의 항목을 가진 배열에서 최소 값을 찾기 위해 N번 비교해야 하고, 이를 N번 반복하므로 N^2의 연산이 필요합니다.
- 장점: 교환 횟수가 적어, 비교적은 적은 교환 작업을 필요로 합니다.
- 단점: 배열의 킈가 커지면 비효율적입니다.

## 삽입 정렬

삽입 정렬은 배열의 두 번째 요소부터 시작하여, 그 요소를 그 앞의 요소들과 비교하고, 적절한 위치에 삽입하는 방식으로 배열을 정렬합니다. 즉, 앞의 부분이 이미 정렬되어 있다고 가정하고, 새 항목을 올바른 위치에 삽입합니다.

### 삽입 정렬의 과정:

1. 배열의 두 번째 요소부터 시작합니다.
2. 그 요소를 앞의 정렬된 부분과 비교하여 적절한 위치에 삽입합니다.
3. 이 과정을 배열의 끝까지 반복합니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f20df8a-f7c9-49b2-a083-ea645e86826a/1505dbf5-6785-484a-94f6-c4a776b2d5db/image.png)

### 삽입 정렬의 구현

```java
public class InsertionSort {
	public static void sort (int[] arr) {
		int N = arr.length;
		for (int i = 1; i < N; i++) {
			int key = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
	}
}
```

### 삽입 정렬 설명

- 시간 복잡도: 최악의 경우 O(N^2)입니다. 배열이 이미 역순으로 정렬되어 있을 때, 모든 요소를 비교해야 합니다.
- 장점: 배열이 거의 정렬된 상태인 경우, 성능이 매우 좋습니다. 최선의 경우 시간 복잡도는 O(N)입니다.
- 단점: 배열이 커지면 비효율적입니다.

## 버블 정렬(Bubble Sort)

버블 정렬은 배열을 순차적으로 순회하면서, 서로 인접한 두 요소를 비교하여 교환하는 방식으로 배열을 정렬합니다. 즉, 배열을 거듭 순회하며 가장 큰 요소를 끝으로 “떠오르게” 하는 방식입니다.

### 버블 정렬의 과정

1. 배열의 첫 번째 요소부터 시작하여 인접한 두 요소를 비교합니다.
2. 두 요소의 크기를 비교하여, 앞의 요소가 더 크다면 두 요소를 비교합니다.
3. 이 과정을 배열끝까지 반복한 후, 다시 처음부터 배열을 순회하며 교환이 일어나지 않을 때까지 반복합니다.

### 버블 정렬의 구현

```java
public class BubbleSort {
	public static void sort(int[] arr) {
		int N = arr.length;
		boolean swapped;
		for (int i =0; i< N-1; i++) {
			swapped = false;
			for (int j=0; j < N - i - 1; j++) {
				if (arr[j] > arr[j+1]) {
					swap(arr, j, j+1);
					swapped = true;
				}
			}
			if (!swapped) break;
		}
	}
	
	private static void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
}
```

### 버블 정렬 설명

- 시간 복잡도: 최악의 경우 시간 복잡도는 O(N^2) 입니다. 배열이 역순으로 정렬되어 있으면, 모든 요소를 서로 비교하고 교환해야 하기 때문입니다.
- 장점: 구현이 매우 간단하고, 배열이 거의 정렬된 상태라면 최선의 경우 시간 복잡도는 O(N)이 됩니다.
- 단점: 성능이 다른 기본 정렬 알고리즘에 비해 좋지 않으며, 특히 큰 배열에서는 비효율적입니다.

## 세 가지 정렬 알고리즘의 비교

이제 선택 정렬, 삽입 정렬, 그리고 버블 정렬의 성능을 비교해 보겠습니다.

| 알고리즘  | 최선의 경우 | 평균 | 최악의 경우 | 특징 |
| --- | --- | --- | --- | --- |
| 선택 정렬 | O(N^2) | O(N^2) | O(N^2) | 교환 횟수가 적음. 비교 연산이 중요 |
| 삽입 정렬 | O(N) | O(N^2) | O(N^2) | 거의 정렬된 배열에서 빠르게 동작 |
| 버블 정렬 | O(N) | O(N^2) | O(N^2) | 구현이 가장 간단하지만 성능이 낮음 |
- 선택 정렬: 항상 O(N^2)의 성능을 가지므로, 비교 연산이 횟수가 일정합니다. 교환 연산이 적지만, 성능 면에서 그다지 효율적이지 않습니다.
- 삽입 정렬: 거의 정렬된 배열에서 빠르게 동작하며, 작은 배열에서는 매우 유용합니다.
- 버블 정렬: 구현이 매우 간단하지만, 실제로는 다른 정렬 알고리즘보다 성능이 낮습니다.

### 선택 정렬, 삽입 정렬, 버블 정렬의 사용사례

- 선택 정렬은 교환 비용이 높고 비교 비용이 상대적으로 낮은 상황에서 사용될 수 있습니다.
- 삽입 정렬은 배열이 이미 거의 정렬된 상태일 때 매우 효율적이며, 작은 데이터셋에 적합합니다.
- 버블 정렬은 알고리즘을 배우는 목적으로 적합하며, 실제로는 거의 사용되지 않습니다.

# 2.2 합병 정렬(Mergesort)

합병정렬(Mergesort)은 분할 정복(Divide and Conquer)기법을 사용하는 효율적인 정렬 알고리즘입니다. 합병 정렬은 배열을 반으로 나누어 각각을 정렬한 후, 두 정렬된 배열을 합쳐서 하나의 정렬된 배열로 만듭니다. 이러한 과정이 재귀적으로 이루어지며, 정렬 효율이 매우 높습니다.

## 합병 정렬의 원리

1. 분할(Divide): 배열을 중간으로 나눕니다.
2. 정복(Conquer): 나누어진 각 부분을 재귀적으로 정렬합니다.
3. 합병(Combine): 정렬된 두 부분을 병합하여 하나의 배열로 만듭니다.

이 과정을 반복하면 최종적으로 정렬된 배열을 얻을 수 있습니다.

```java
public class MergeSort {
    private static void merge(int[] arr, int[] aux, int low, int mid, int high) {
        for (int k = low; k <= high; k++) {
            aux[k] = arr[k];
        }
        
        int i = low, j = mid + 1;
        for (int k = low; k <= high; k++) {
            
            // 왼쪽과 오른쪽 배열이 aux인자가 다 소진된 상태(나머지 열을 그대로 복사한다)
            if (i > mid) arr[k] = aux[j++]; // 왼쪽 배열이 소진되었을 때
            else if (j > high) arr[k] = aux[i++]; // 오른쪽 배열이 소진되었을 때
            
            // 왼쪽과 오른쪽 각 첫번째 배열을 비교하여 작은 숫자를 본 배열에 추가한다
            else if (aux[j] < aux[i]) arr[k] = aux[j++]; // 오른쪽 요소가 왼쪽 요소보다 작을 때
            else arr[k] = aux[i++]; // 왼쪽 요소가 오른쪽 요소보다 작을 때
        }
    }

    public static void sort(int[] arr, int[] aux, int low, int high) {
        if (high <= low) return; // 더이상 쪼개지지 않는다
        int mid = low + (high - low) / 2;
        sort(arr, aux, low, mid);
        sort(arr, aux, mid + 1, high);
        merge(arr, aux, low, mid, high);
    }

    public static void sort(int[] arr) {
        int[] aux = new int[arr.length];
        sort(arr, aux, 0, arr.length - 1);
    }
}
```

## 합병 정렬 설명

1. 분할 단계에서는 배열을 중간 지점에서 나누어 두 하위 배열로 분리합니다.
2. 각 하위 배열을 재귀적으로 정렬한 후, 합병 단계에서 두 하위 배열을 하나의 정렬된 배열로 병합합니다.
3. 이 과정은 배열의 크기가 1이 될 때까지 계속됩니다 → 더이상 쪼개지지 않는 단위

## 시간 복잡도

합병 정렬의 시간 복잡도는 O(N log N)입니다. 배열을 반으로 나누는 과정이 log N 단계이며, 각 단계에서 모든 요소를 합병하는 데 O(N)이 걸리기 때문입니다.

추가적인 배열공간이 필요하므로 O(N)의 공간 복잡도를 가집니다.

## 합병 정렬의 장점과 단점

장점

- 안정 정렬: 같은 값의 순서가 유지됩니다.
- O(Nlog N)의 시간 복잡도를 가지므로, 큰 데이터셋에서도 효율적입니다.
- 분할 정복 방식이므로, 여러 프로세서에서 병렬 처리가 가능합니다.

단점

- 추가 메모리 필요: 보조 배열이 필요하므로, O(N)의 추가 공간 복잡도가 있습니다.
- 병합 단계의 메모리 이동 비용: 각 병합 단계에서 배열을 복사하므로, 메모리 이동이 잦습니다.

## 합병 정렬의 구현 예시와 분석

합병 정렬은 추가 공간이 필요하긴 하지만 로그 시간복잡도와 안정성을 제공하므로 대규모 데이터셋이나 안정 정렬이 중요한 상황에서 널리 사용됩니다. 메모리 사용이 문제되지 않는다면 합병 정렬은 매우 효율적인 선택이 될 수 있습니다.
