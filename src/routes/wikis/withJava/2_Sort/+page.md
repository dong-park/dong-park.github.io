---
title: 2. Sort
summary: 정렬 알고리즘인 선택 정렬, 삽입 정렬, 버블 정렬에 대해 설명합니다. 선택 정렬은 O(N^2)의 시간 복잡도를 가지며, 비교 연산이 중요합니다. 삽입 정렬은 거의 정렬된 배열에서 효율적이며, 최선의 경우 O(N)입니다. 버블 정렬은 구현이 간단하지만 성능이 낮고, 최악의 경우 O(N^2)입니다. 세 가지 알고리즘의 성능을 비교하고 각 알고리즘의 사용 사례를 제시합니다.
date: '2024-10-03'
tags: ['']
---

# 2.1 Elementary Sorts

정렬은 컴퓨터 과학에서 매우 중요한 작업 중 하나로, 데이터를 순서대로 정렬하는 알고리즘 입니다. 이 강의에서는 가장 기본적인 정렬 알고리즘인 선택정렬, 삽입정렬, 그리고 버블 정렬에 대해 배웁니다.

이 알고리즘들은 이해하기 쉽고, 작은 데이터셋에 사용할 수 있습니다. 그러나 큰 데이터셋에서는 비효율적인 수 있습니다.

## 선택정렬

선택 정렬은 배열에서 가장 작은 항목을 찾아 첫 번째 위치에 놓고, 그다음 작은 항목을 찾아 두 번째 위치에 놓는 과정을 반복하여 배열을 정렬합니다.

### 선택 정렬의 과정

1. 배열에서 가장 작은 요소를 찾습니다.
2. 그 요소를 첫 번째 요소와 교환합니다.
3. 그다음 작은 요소를 찾고, 두 번째 요소와 교환합니다.
4. 이 과정을 반복하여 배열 전체를 정렬합니다.

### 선택 정렬의 구현

```java
public class SelectionSort {
	public static void sort(int[] arr) {
		int N = arr.length;
		for (int i=0; i<N; i++){
			int min = i;
			for (int j = i+1; j<N; j++) {
				if (arr[j] < arr[min]) {
					min = j;
				}
			}
		}
	}
	
	private static void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
}
```

### 선택 정렬 설명:

- 시간 복잡도: 선택 정렬의 시간 복잡도는 항상 O(N^2)입니다. N개의 항목을 가진 배열에서 최소 값을 찾기 위해 N번 비교해야 하고, 이를 N번 반복하므로 N^2의 연산이 필요합니다.
- 장점: 교환 횟수가 적어, 비교적은 적은 교환 작업을 필요로 합니다.
- 단점: 배열의 킈가 커지면 비효율적입니다.

## 삽입 정렬

삽입 정렬은 배열의 두 번째 요소부터 시작하여, 그 요소를 그 앞의 요소들과 비교하고, 적절한 위치에 삽입하는 방식으로 배열을 정렬합니다. 즉, 앞의 부분이 이미 정렬되어 있다고 가정하고, 새 항목을 올바른 위치에 삽입합니다.

### 삽입 정렬의 과정:

1. 배열의 두 번째 요소부터 시작합니다.
2. 그 요소를 앞의 정렬된 부분과 비교하여 적절한 위치에 삽입합니다.
3. 이 과정을 배열의 끝까지 반복합니다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/9f20df8a-f7c9-49b2-a083-ea645e86826a/1505dbf5-6785-484a-94f6-c4a776b2d5db/image.png)

### 삽입 정렬의 구현

```java
public class InsertionSort {
	public static void sort (int[] arr) {
		int N = arr.length;
		for (int i = 1; i < N; i++) {
			int key = arr[i];
			int j = i - 1;
			while (j >= 0 && arr[j] > key) {
				arr[j + 1] = arr[j];
				j--;
			}
			arr[j + 1] = key;
		}
	}
}
```

### 삽입 정렬 설명

- 시간 복잡도: 최악의 경우 O(N^2)입니다. 배열이 이미 역순으로 정렬되어 있을 때, 모든 요소를 비교해야 합니다.
- 장점: 배열이 거의 정렬된 상태인 경우, 성능이 매우 좋습니다. 최선의 경우 시간 복잡도는 O(N)입니다.
- 단점: 배열이 커지면 비효율적입니다.

## 버블 정렬(Bubble Sort)

버블 정렬은 배열을 순차적으로 순회하면서, 서로 인접한 두 요소를 비교하여 교환하는 방식으로 배열을 정렬합니다. 즉, 배열을 거듭 순회하며 가장 큰 요소를 끝으로 “떠오르게” 하는 방식입니다.

### 버블 정렬의 과정

1. 배열의 첫 번째 요소부터 시작하여 인접한 두 요소를 비교합니다.
2. 두 요소의 크기를 비교하여, 앞의 요소가 더 크다면 두 요소를 비교합니다.
3. 이 과정을 배열끝까지 반복한 후, 다시 처음부터 배열을 순회하며 교환이 일어나지 않을 때까지 반복합니다.

### 버블 정렬의 구현

```java
public class BubbleSort {
	public static void sort(int[] arr) {
		int N = arr.length;
		boolean swapped;
		for (int i =0; i< N-1; i++) {
			swapped = false;
			for (int j=0; j < N - i - 1; j++) {
				if (arr[j] > arr[j+1]) {
					swap(arr, j, j+1);
					swapped = true;
				}
			}
			if (!swapped) break;
		}
	}
	
	private static void swap(int[] arr, int i, int j) {
		int temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
}
```

### 버블 정렬 설명

- 시간 복잡도: 최악의 경우 시간 복잡도는 O(N^2) 입니다. 배열이 역순으로 정렬되어 있으면, 모든 요소를 서로 비교하고 교환해야 하기 때문입니다.
- 장점: 구현이 매우 간단하고, 배열이 거의 정렬된 상태라면 최선의 경우 시간 복잡도는 O(N)이 됩니다.
- 단점: 성능이 다른 기본 정렬 알고리즘에 비해 좋지 않으며, 특히 큰 배열에서는 비효율적입니다.

## 세 가지 정렬 알고리즘의 비교

이제 선택 정렬, 삽입 정렬, 그리고 버블 정렬의 성능을 비교해 보겠습니다.

| 알고리즘  | 최선의 경우 | 평균 | 최악의 경우 | 특징 |
| --- | --- | --- | --- | --- |
| 선택 정렬 | O(N^2) | O(N^2) | O(N^2) | 교환 횟수가 적음. 비교 연산이 중요 |
| 삽입 정렬 | O(N) | O(N^2) | O(N^2) | 거의 정렬된 배열에서 빠르게 동작 |
| 버블 정렬 | O(N) | O(N^2) | O(N^2) | 구현이 가장 간단하지만 성능이 낮음 |
- 선택 정렬: 항상 O(N^2)의 성능을 가지므로, 비교 연산이 횟수가 일정합니다. 교환 연산이 적지만, 성능 면에서 그다지 효율적이지 않습니다.
- 삽입 정렬: 거의 정렬된 배열에서 빠르게 동작하며, 작은 배열에서는 매우 유용합니다.
- 버블 정렬: 구현이 매우 간단하지만, 실제로는 다른 정렬 알고리즘보다 성능이 낮습니다.

### 선택 정렬, 삽입 정렬, 버블 정렬의 사용사례

- 선택 정렬은 교환 비용이 높고 비교 비용이 상대적으로 낮은 상황에서 사용될 수 있습니다.
- 삽입 정렬은 배열이 이미 거의 정렬된 상태일 때 매우 효율적이며, 작은 데이터셋에 적합합니다.
- 버블 정렬은 알고리즘을 배우는 목적으로 적합하며, 실제로는 거의 사용되지 않습니다.


