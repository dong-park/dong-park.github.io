---
title: 정렬
summary: ""
date: '2024-06-01'
tags: [ '' ]
---

# 버블정렬

데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식 시간 복잡도는 O(n²)으로 다른 정렬 알고리즘보다 속도가 느린 편입니다.

## 버블 정렬 과정

1. 비교 연산이 필요한 루프 범위를 설정한다.
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다.
4. 루프 범위가 끝날 때 까지 2~3을 반복한다.
5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.
6. 비교 대상이 없을 때까지 1~5를 반복한다.

# 선택정렬

선택 정렬은 대상 데이터에서 최대나 최소 데이터를 데이터나 나열된 순으로 찾아 가며 선택하는 방법입니다.
선택 정렬은 구현 방법이 복잡하고, 시간 복잡도도 O(n²)으로 효율적이지 않아 코딩 테스트 에서는 잘 사용하지 않습니다.

## 선택 정렬 과정

1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
3. 가장 앞에 있는 데이터으 위치를 변경해 남은 정렬 부분의 범위를 축소한다.
4. 전체 데이터 크기 만큼 index가 커질 때까지, 남은 정렬 부분이 없어질때까지 반복한다.

# 삽입 정렬

삽입 정렬은 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식입니다.
평균 시간 복잡도는 O(n²)으로 느린 편이지만 구현하기 쉽습니다.

## 삽입 정렬 수행 방식

1. 현재 index에 있는 데이터 값을 선택한다.
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽일될 위치를 탐색한다.
3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
5. 전체 데이터의 크기만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 떄까지 반복한다.

# 퀵 정렬

퀵 정렬은 기준값을 선정해 해당값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘 입니다.
퀵 정렬 수행 방식

1. 피벗 설정: 배열에서 피벗(pivot)을 설정합니다.
2. 데이터 분할: 피벗을 기준으로 데이터를 두 개의 집합으로 나눕니다.
   - a. start 이동: start가 가리키는 값이 피벗 값보다 작으면, start를 오른쪽으로 한 칸 이동합니다.
   - b. end 이동: end가 가리키는 값이 피벗 값보다 크면, end를 왼쪽으로 한 칸 이동합니다.
   - c. 교환: start가 가리키는 값이 피벗 값보다 크고, end가 가리키는 값이 피벗 값보다 작으면, start와 end가 가리키는 값을 교환한 후, start는 오른쪽으로, end는 왼쪽으로 한 칸 이동합니다.
   - d. 반복: start와 end가 만날 때까지 a~c 단계를 반복합니다.
   - e. 피벗 위치 확정: start와 end가 만나면, 피벗 값을 start와 end가 만난 지점에 넣습니다. 피벗 값이 더 크면 왼쪽, 더 작으면 오른쪽에 삽입합니다.
3. 재귀 호출: 나뉜 두 집합에서 각각 다시 피벗을 선정하여 위 과정을 반복합니다.
4. 완료: 분리된 집합이 1개 이하가 될 때까지 1~3 과정을 반복합니다.

퀵 정렬은 빠르고 효율적이므로 코딩 테스트에서도 자주 사용됩니다. 재귀 함수 형태로 구현해보는 것을 추천합니다.

피벗을 정하는 방법
- pivot \= K: K번째 수를 찾았으므로 알고리즘을 종료합니다.
- pivot \> K: pivot의 왼쪽 부분에 K가 있으므로 왼쪽 부분(start ~ pivot-1)만 정렬합니다.
- pivot \< K: pivot의 오른쪽 부분에 K가 있으므로 오른쪽 부분(pivot+1 ~ end)만 정렬합니다.

# 병합 정렬

병합정렬은 분할정복 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘 입니다. 시간 복잡도 평균값은 O(nlongn) 입니다.

## 병합 정렬 수행 방식

1. 초기 데이터 [27, 12, 43, 39, 8, 32, 50, 29]를 가장 작은 단위로 분할하여 각 부분 집합을 정렬합니다.
2. 첫 번째 단계에서는 [27, 12]는 [12, 27]로, [43, 39]는 [39, 43]으로, [8, 32]는 그대로, [50, 29]는 [29, 50]으로 정렬됩니다.
3. 두 번째 단계에서는 [12, 27]과 [39, 43]을 병합하여 [12, 27, 39, 43]로, [8, 32]와 [29, 50]을 병합하여 [8, 29, 32, 50]로 만듭니다.
4.	마지막 단계에서는 두 개의 집합 [12, 27, 39, 43]과 [8, 29, 32, 50]을 병합하여 최종적으로 [8, 12, 27, 29, 32, 39, 43, 50]로 정렬합니다.

이와 같이 병합 정렬은 데이터를 분할하고 병합하면서 정렬하는 과정을 거쳐 전체 데이터를 정렬합니다.




